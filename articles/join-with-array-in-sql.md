---
title: "配列でJOINする in SQL"
publication_name: "aidemy"
emoji: "💫"
type: "tech"
topics: ["sql"]

published: true
---

この記事は『[PostgreSQLで配列のidとjoinして並び替えるのが難しい](https://qiita.com/nishimura/items/575e642503139229059a)』を参考にしています。

動作確認はPostgreSQLで行っています。

## テーブル定義

まず前提条件として以下のようなユーザーテーブルとユーザーグループテーブルを考えます。

```sql
CREATE TABLE user_groups (
    user_group_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
    user_ids INTEGER ARRAY
);

CREATE TABLE users (
    user_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);
```

`INTEGER GENERATED BY DEFAULT AS IDENTITY` は標準SQLにおける連番の書き方です。
参考：『[Identity columns](https://qiita.com/nuko_yokohama/items/7d0d5525bcefaa3332ce)』

:::details データ投入

```sql
INSERT INTO
    users (name)
VALUES
    ('Ichiro'),
    ('Jiro'),
    ('Saburo'),
    ('Shiro'),
    ('Goro');

INSERT INTO
    user_groups (name, user_ids)
VALUES
    ('group_1', ARRAY[1, 3, 2]),
    ('group_2', ARRAY[3, 4, 5]);
```

:::

この`user_groups`の`user_ids`で紐づけて`users`テーブルのデータを取得する方法を紹介するというのがこの記事の内容になります。

## サブクエリを使う書き方

`user_groups`の`user_ids`で紐づけて`users`テーブルのデータを取得するには、`GROUP BY`を使って以下のように書くことができます。

```sql
SELECT
    user_groups.user_group_id,
    user_groups.name,
    (
        SELECT
            json_agg(users)
        FROM
            users
        WHERE
            users.user_id = any(user_groups.user_ids)
    ) AS users
FROM
    user_groups;
```

`users.user_id = any(user_groups.user_ids)` は等号が成り立つ要素が`user_groups.user_ids`に存在するとき`TRUE`となります。[^1]

ただし、この書き方では配列内の順序が維持される保証がありません。
つまり `user_groups.user_ids` と異なる順番で`users`の中身が並ぶ可能性があります。
そこで、配列の順序を維持させる方法を紹介していきます。クエリは以下のようになります。

```sql
SELECT
    user_groups.user_group_id,
    user_groups.name,
    (
        SELECT
            json_agg(users ORDER BY user_ids.i)
        FROM
            unnest(user_groups.user_ids) WITH ORDINALITY AS user_ids(user_id, i)
        JOIN users USING (user_id)
    ) AS users
FROM
    user_groups;
```

順を追って上のコードを説明していきましょう。

まず `unnest(user_groups.user_ids) WITH ORDINALITY AS user_ids(user_id, i)` から説明します。
`unnest(user_groups.user_ids)` で`user_ids`を配列をテーブル (より正確には行の集合) に変換しています。[^2]
`WITH ORDINALITY` でテーブルの列として配列のインデックス (1始まり) を加えています。[^3]
つまり、user_groups.user_idsの中身とインデックスを列として持つテーブルが作成されています。
`AS user_ids(user_id, i)` で上記のテーブルのエイリアスを指定しています。テーブルに`user_ids`、`user_groups.user_ids`の中身に`user_id`、配列のインデックスに`i` というエイリアスを指定しています。

次に `JOIN users USING (user_id)` で`users`を`JOIN`して、`json_agg(users ORDER BY user_ids.i) AS users` で集約しています。
`json_agg`は入力 (`users`) をJSONの配列として格納します。[^4]
`ORDER BY user_ids.i` で`user_ids`のインデックスと同じ順序で配列の要素が並ぶようにしています。[^4]

これでやりたかったクエリを作成することができました。

## 他の方法

配列の順序を問わないなら、以下のように`GROUP BY`で書くこともできます。

```sql
SELECT
    user_groups.user_group_id,
    user_groups.name,
    json_agg(users) AS users
FROM
    user_groups
JOIN
    users ON users.user_id = ANY(user_groups.user_ids)
GROUP BY
    user_groups.user_group_id;
```

配列の順序を維持する場合、配列を作成する場所をサブクエリのときと異なる場所で行うこともできます。

```sql
SELECT
    user_groups.user_group_id,
    user_groups.name,
    user_arrays.user_array AS users
FROM
    user_groups
LEFT JOIN LATERAL (
    SELECT
        json_agg(users ORDER BY user_ids.i) AS user_array
    FROM
        unnest(user_groups.user_ids) WITH ORDINALITY AS user_ids(user_id, i)
    JOIN users USING (user_id)
) user_arrays ON true
ORDER BY
    user_groups.user_group_id;
```

`JOIN`する集合は `unnest(user_groups.user_ids)`の箇所で`user_groups`を参照しています。
このようにJOINする集合が前の`FROM`句のテーブルに依存しているときに`LATERAL`を指定する必要があるので`LEFT JOIN LATERAL` と書いています。[^5]

[^1]: https://www.postgresql.jp/document/15/html/functions-comparisons.html#id-1.5.8.32.20
[^2]: https://www.postgresql.jp/document/15/html/functions-array.html
[^3]: https://www.postgresql.jp/document/15/html/functions-srf.html
[^4]: https://www.postgresql.jp/document/15/html/functions-aggregate.html
[^5]: https://www.postgresql.jp/document/15/html/queries-table-expressions.html#QUERIES-LATERAL

## おわりに

配列で紐づけてJOINする方法を調べてみたところ、前提知識が多く調べるのが大変だったので記事にしました。
この記事がこれから学習する人のショートカットになれば幸いです。
