---
title: "配列でJOINする in SQL"
publication_name: "aidemy"
emoji: "💫"
type: "tech"
topics: ["sql"]

published: true
---

この記事は『[PostgreSQLで配列のidとjoinして並び替えるのが難しい](https://qiita.com/nishimura/items/575e642503139229059a)』を参考にしています。

動作確認はPostgreSQLで行っています。

## テーブル定義

まず前提条件として以下のようなアイテムテーブルとグループテーブルを考えます。

```sql
CREATE TABLE items (
    item_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE groups (
    group_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
    item_ids INTEGER ARRAY
);
```

`INTEGER GENERATED BY DEFAULT AS IDENTITY` は標準SQLにおける連番の書き方です。
参考：『[Identity columns](https://qiita.com/nuko_yokohama/items/7d0d5525bcefaa3332ce)』

:::details データ投入

```sql
INSERT INTO
    items (name)
VALUES
    ('item_1'),
    ('item_2'),
    ('item_3'),

INSERT INTO
    groups (name, item_ids)
VALUES
    ('group_1', ARRAY[1, 2]),
    ('group_2', ARRAY[3, 2]);
```

:::

この`groups`の`item_ids`で紐づけて以下のように`items`テーブルのデータを取得する方法を紹介するというのがこの記事の内容になります。

|group_id|name|items|
|-|-|-|
|1|group_1|[{ item_id: 1, name: "item_1" }, { item_id: 2, name: "item_2" }]|
|2|group_2|[{ item_id: 3, name: "item_3" }, { item_id: 2, name: "item_2" }]|

## サブクエリを使う書き方

`groups`の`item_ids`で紐づけて`items`テーブルのデータを取得するには、`GROUP BY`を使って以下のように書くことができます。

```sql
SELECT
    groups.group_id,
    groups.name,
    (
        SELECT
            json_agg(items)
        FROM
            items
        WHERE
            items.item_id = any(groups.item_ids)
    ) AS items
FROM
    groups;
```

`items.item_id = any(groups.item_ids)` は等号が成り立つ要素が`groups.item_ids`に存在するとき`TRUE`となります。[^1]

ただし、この書き方では配列内の順序が維持される保証がありません。
つまり `groups.item_ids` と異なる順番で`items`の中身が並ぶ可能性があります。
そこで、配列の順序を維持させる方法を紹介していきます。クエリは以下のようになります。

```sql
SELECT
    groups.group_id,
    groups.name,
    (
        SELECT
            json_agg(items ORDER BY item_ids.i)
        FROM
            unnest(groups.item_ids) WITH ORDINALITY AS item_ids(item_id, i)
        JOIN items USING (item_id)
    ) AS items
FROM
    groups;
```

順を追って上のコードを説明していきましょう。

まず `unnest(groups.item_ids) WITH ORDINALITY AS item_ids(item_id, i)` から説明します。
`unnest(groups.item_ids)` で配列`item_ids`をテーブル (より正確には行の集合) に変換しています。[^2]
`WITH ORDINALITY` でテーブルの列として配列のインデックス (1始まり) を加えています。[^3]
つまり、groups.item_idsの中身とインデックスを列として持つテーブルが作成されています。
`AS item_ids(item_id, i)` で上記のテーブルのエイリアスを指定しています。テーブルに`item_ids`、`groups.item_ids`の中身に`item_id`、配列のインデックスに`i` というエイリアスを指定しています。

次に `JOIN items USING (item_id)` で`items`を`JOIN`して、`json_agg(items ORDER BY item_ids.i) AS items` で集約しています。
`json_agg`は入力 (`items`) をJSONの配列として格納します。[^4]
`ORDER BY item_ids.i` で`item_ids`のインデックスと同じ順序で配列の要素が並ぶようにしています。[^4]

これでやりたかったクエリを作成することができました。

## 他の方法

配列の順序を問わないなら、以下のように`GROUP BY`で書くこともできます。

```sql
SELECT
    groups.group_id,
    groups.name,
    json_agg(items) AS items
FROM
    groups
JOIN
    items ON items.item_id = ANY(groups.item_ids)
GROUP BY
    groups.group_id;
```

配列の順序を維持する場合、配列を作成する場所をサブクエリのときと異なる場所で行うこともできます。

```sql
SELECT
    groups.group_id,
    groups.name,
    user_arrays.user_array AS items
FROM
    groups
LEFT JOIN LATERAL (
    SELECT
        json_agg(items ORDER BY item_ids.i) AS user_array
    FROM
        unnest(groups.item_ids) WITH ORDINALITY AS item_ids(item_id, i)
    JOIN items USING (item_id)
) user_arrays ON true
ORDER BY
    groups.group_id;
```

`JOIN`する集合は `unnest(groups.item_ids)`の箇所で`groups`を参照しています。
このようにJOINする集合が前の`FROM`句のテーブルに依存しているときに`LATERAL`を指定する必要があるので`LEFT JOIN LATERAL` と書いています。[^5]

[^1]: https://www.postgresql.jp/document/15/html/functions-comparisons.html#id-1.5.8.32.20
[^2]: https://www.postgresql.jp/document/15/html/functions-array.html
[^3]: https://www.postgresql.jp/document/15/html/functions-srf.html
[^4]: https://www.postgresql.jp/document/15/html/functions-aggregate.html
[^5]: https://www.postgresql.jp/document/15/html/queries-table-expressions.html#QUERIES-LATERAL

## おわりに

配列で紐づけてJOINする方法を調べてみたところ、前提知識が多く調べるのが大変だったので記事にしました。
この記事がこれから学習する人のショートカットになれば幸いです。
