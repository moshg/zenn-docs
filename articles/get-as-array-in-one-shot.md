---
title: "PostgreSQLで行に複数紐づくデータを配列として一発で取得する"
publication_name: "aidemy"
emoji: "🥌"
type: "tech"
topics: ["sql", "postgresql"]

published: false
---

## まえがき

「group∋item」のような入れ子構造があるとき、SQLでデータをどう取得するかを迷ったことはありませんか？
SQLにおいて複数のグループを取得するときに、アイテムも一緒に取得するのはあまり簡単ではありません。
私は初めてSQLに触ったときにどうすればいいかわからず、アプリケーション側で無理やり実現した記憶があります。[^orm]
そこで当時の自分のような人に向けて、SQLで入れ子になったデータを取得する方法を紹介したいと思います！

[^orm]: クエリビルダーじゃなくORマッパーを使っていれば、勝手にいい感じにやってくれて困らずに済んだという説もある

動作確認はPostgreSQL 15.3で行っています。

## テーブル定義

まず以下のようなテーブルを考えます。

```sql
CREATE TABLE groups (
    group_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE items (
    group_id INTEGER,
    item_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    FOREIGN KEY (group_id) REFERENCES groups(group_id)
);
```

`INTEGER GENERATED BY DEFAULT AS IDENTITY` は標準SQLにおける連番の書き方です。
参考：『[Identity columns](https://qiita.com/nuko_yokohama/items/7d0d5525bcefaa3332ce)』

:::details データ投入

```sql
INSERT INTO
    groups (name)
VALUES
    ('group_1'),
    ('group_2');

INSERT INTO
    items (group_id, name)
VALUES
    (1, 'item_1'),
    (1, 'item_2'),
    (2, 'item_3');
```

:::

このとき以下のようにデータを取得したいというのがこの記事の目標になります。

|group_id|name|items|
|-|-|-|
|1|group_1|[{ item_id: 1, name: "item_1" }, { item_id: 2, name: "item_2" }]|
|2|group_2|[{ item_id: 3, name: "item_3" }]|

## データを配列として取得する

いきなり結論ですが、以下のようにサブクエリを使ってデータを取得することができます。[^jsonb]

```sql
select
    groups.group_id AS id,
    groups.name,
    (
        select
            jsonb_agg(items)
        from
            items
        where
            items.group_id = groups.group_id
    ) as items
from
    groups
```

`jsonb_agg`[^jsonb_agg]は集約関数であり、入力をJSON配列に格納します。

[^jsonb]: JSONBとは何かの解説：『[PostgreSQLのjson/jsonb型](https://zenn.dev/snagasawa/articles/postgresql_json_and_jsonb_type)』
JSONではなくJSONBを使っているのはなんとなくです
[^jsonb_agg]: https://www.postgresql.jp/document/15/html/functions-aggregate.html

このクエリを実行すると以下のデータを取得できます。

|group_id|name|items|
|-|-|-|
|1|group_1|[{"name": "item_1", "item_id": 1, "group_id": 1}, {"name": "item_2", "item_id": 2, "group_id": 1}]|
|2|group_2|[{"name": "item_3", "item_id": 3, "group_id": 2}]|

もし作成日時などで配列の要素の順番を制御したいのであれば以下のように集約時に`ORDER BY`することもできます。[^order-by]

[^order-by]: https://www.postgresql.jp/document/15/html/sql-expressions.html#SYNTAX-AGGREGATES

```sql
jsonb_agg(items ORDER BY items.created_at) -- この記事で定義したテーブルにcreated_atはないが例として
```

ただし`items`テーブルをまるごと`jsonb_agg`で取り込んでしまったので、`items`フィールドに`group_id`が含まれてしまっています。
`item_id`, `name` だけに絞りたい場合は`jsonb_build_object`[^jsonb-fn]というJSONBオブジェクトを作成する関数が使えます。
`jsonb_build_object`の使い方の例は以下のようになります。

```sql
jsonb_build_object('foo', 1, 'bar', 'baz') -- { "foo": 1, "bar": "baz" }
```

[^jsonb-fn]: https://www.postgresql.jp/document/15/html/functions-json.html

この`jsonb_build_object`を使ってクエリを書き換えると次のようになります。

```sql
select
    groups.group_id,
    groups.name,
    (
        select
            jsonb_agg(jsonb_build_object(
                'item_id', items.item_id,
                'name', items.name
            ))
        from
            items
        where
            items.group_id = groups.group_id
    ) as items
from
    groups
```

これで欲しかったデータを取得できました！

|group_id|name|items|
|-|-|-|
|1|group_1|[{ item_id: 1, name: "item_1" }, { item_id: 2, name: "item_2" }]|
|2|group_2|[{ item_id: 3, name: "item_3" }]|

## データを配列として取得する (入れ子が多重の場合)

さらに入れ子になったデータを取得する場合も見ておきましょう。
追加で以下のようにアイテムの属性テーブルを考えます。

```sql
CREATE TABLE attributes (
    item_id INTEGER,
    attr_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    FOREIGN KEY (item_id) REFERENCES items(item_id)
);
```

:::details データ投入

```sql
INSERT INTO
    attributes (item_id, name)
VALUES
    (1, 'attr_1'),
    (1, 'attr_2'),
    (3, 'attr_3'),
    (2, 'attr_4');
```

:::

このときも対応してサブクエリをさらに入れ子にすることで、データを取得できます。

```sql
select
    groups.group_id,
    groups.name,
    (
        select
            jsonb_agg(jsonb_build_object(
            	'name', items.name,
                'item_id', items.item_id,
                'attributes', (
                    select
                        jsonb_agg(jsonb_build_object(
                        	'attr_id', attrs.attr_id,
                            'name', attrs.name
                        )) as attributes
                    from
                        attributes AS attrs
                    where
                        attrs.item_id = items.item_id
                )
            ))
        from
            items
        where
            items.group_id = groups.group_id
    ) as items
from
    groups
```

|group_id|name|items|
|-|-|-|
|1|group_1|[{"name": "item_1", "item_id": 1, "attributes": [{"name": "attr_1", "attr_id": 1}, {"name": "attr_2", "attr_id": 2}]}, {"name": "item_2", "item_id": 2, "attributes": [{"name": "attr_4", "attr_id": 4}]}]|
|2|group_2|[{"name": "item_3", "item_id": 3, "attributes": [{"name": "attr_3", "attr_id": 3}]}]|

## あとがき

SQLが案外高機能で驚きますね。
SQLだけでも普通のプログラミング言語のようにネストしたデータ構造を実現して、データ周りの処理をDBに任せることができます。
この記事が当時の自分のような人の助けになっていれば嬉しいです！

最後に、データの入れ子を子からの参照ではなく、親からの参照 (配列) で表現している場合の記事を宣伝しておきます: 『[配列でJOINする in SQL](https://zenn.dev/aidemy/articles/join-with-array-in-sql)』
